---
layout: post

title: "C-Day6 2021-06-01. "
excerpt: "배열과 포인터, 메모리할당(프로그램과 프로세스), 동적메모리할당(malloc, free), 다차원포인터, 2차원포인터 "

categories:
  - C
tags:
  - [C]
  
toc: true
toc_sticky: true
 
date: 2021-06-07
last_modified_at: 2021-06-07
---

# 15. 배열과 포인터

### 배열과 포인터 표기법

##### 배열 표기법과 포인터 표기법의 관계

**포인터**는 포인터 변수가 가리키는 <u>메모리의 시작 주소</u>를 기준으로 삼고, 
**배열**도 해당 배열이 사용하는 <u>메모리 그룹의 시작 주소</u>를 기준으로 삼는다.

**따라서 배열과 포인터는 표기법을 서로 바꿔 사용할 수 있다.**

```c++
void main(){
    //배열
    char data[5];
    data[1] = 5;      //아래의 *(data + 1) = 5; 는 해당 data[1] = 5;와 같음
    *(data + 1) = 5;  //위의 data[1] = 5;는 해당 *(data + 1) = 5;와 같음

    //포인터
    char data;
    char *p = &data; //data 변수의 주소를 p에 저장
    *p = 3; //p가 가리키는data 변수에 3을 대입. 아래줄과 같음
    p[0] = 3;  //*p = 3;과 같음. 위줄과 같음
}
```

책 369페이지 하단 필기한 그림 참조

배열과 포인터로 사용하는 것 중 배열 표기법이 더 간단해 보일 수 있다. 하지만 어떤 문법이든 <u>표기가 간단하다는 뜻은 표현에 제약이 있다는 뜻</u>

* **배열 표기법**은 요소를 구성하는 모든 바이트 값을 한 번에 수정하기 때문에 제약있다.
* **포인터 표기법**은 형변환(casting)을 하여 제약 없음(포인터 표기법은 배열 항목의 크기와 상관없이 자유롭게 값을 수정 할 수 있다).    
ex)*(char *)(data + 1) = 0x22; //일시적으로 char *형으로 변환함

---

##### 배열을 사용하는 포인터

포인터와 배열은 연산 횟수의 차이. 배열의 색인 작업도 연산이기 때문에 같은 요소를 반복적으로 사용하는 경우에 효율이 떨어진다.(훨씬 느리다)

예제) 배열 예제를 포인터 사용해서 바꾸기 (포인터를 사용하여 배열의 각 요소에 저장된 값 합산하기)

```c++
void main(){
    char data[5] = {1,2,3,4,5};
    int result = 0, i;
    char *p = data;

    for(i = 0; i < 5; i++){
        result = result + *p;
        p++;
    }
    printf("data 배열의 각 요소의 합은 %d입니다.", result);
}
// 결과 -> data 배열의 각 요소의 합은 15입니다.
```

---

##### 배열을 기준으로 포인터와 합체하기

char *형 포인터 변수가 3개 필요하다면 char *p1, *p2, *p3; 등과 같이 선언해서 포인터 변수를 만들어야 하는데, 포인터가 100개 이상 필요시 불편함. 따라서 포인터 변수도 배열로 선언해서 사용할 수 있다.

```c++
void main(){
    char *p[5];   //char *p1, *p2, *p3, *p4, *p5;라고 선언한것과 같음
}
```

위와 같이 선언하면 포인터가 5개 선언된 것이기 때문에 p 배열의 크기는 20바이트(포인터의 크기는 4바이트 고정)이다.

```c++
void main(){
    char data[3][5];
    char (*p)[5]; //char[5] 크기의 대상을 가리킬 수 있는 포인터 선언. 가독성이 떨어져서 교수님도 잘 안씀
    p = data; //포인터 변수 p는 2차원 배열 data 변수의 시작 주소를 저장
    (*p)[1] = 3; // p가 가리키는 대상의 2번재 항목에 3을 대입. p[0][1];과 같음
    (*(p+1))[2] = 4; //p+1이 가리키는 대상의 3번재 항목에 4를 대입. p[1][2]=4;와 같음
    (*(p+2))[4] = 5;  //p+2가 가리키는 대상의 5번째 항목에 5를 대입. p[2][4]=5;와 같음
    
    //-------------------------------------------위는 교재 내용임

    (*p)[5]; //포인터와 배열이 결합해서 2차원됐음. 줄을 의미(가로)
    //p[0] -> p+0 줄로 이동
    //p[1] -> p+1 줄로 이동

    //-------------------------------------------위아래 교수님 내용

    (*p3)[5] // 한줄
    p3 + 1 //다음줄로 이동
    *(p3+1) + x //x 옆으로 이동. 옆으로 이동하고싶으면 별쳐주기
    *(*(p3+1)+x) //해당 값 가져오기. 별 더쳐주면 갑 가져오기    
}
```

---

# 16. 메모리 할당

### 프로그램과 프로세스

* 프로그래머가 만든 프로그램 실행 파일을 **프로그램**이라고 부른다.
* 운영체제가 실행파일의 명령들을 읽어서 메모리에 재구성하는것을 **프로세스**라고 한다.
* 프로세스는 단순히 실행할 명령들로만이루어져 있는 것이 아니라 다음 그림처럼 여러 가지 정보나 사용자가 입력한 데이터를 기억하는 메모리 공간도 포함하고 있습니다. 이러한 공간을 **세그먼트**라고 한다. (세그먼트 = 정보를 기록하는 메모리 공간)

**프로세스**는 <u>세그먼트의 집합</u>으로 구성되어 있다.

* **코드 세그먼트** : 컴파일러는 C 언어 소스를 기계어로 된 명령문으로 번역해서 실행 파일을 만든다. 실행 파일이 실행되어 프로세스가 만들어지면 이 기계어 명령들은 프로세스의 '코드 세그먼트'에 복사되어 프로그램 실행에 사용된다. (기계어 명령들이 저장되는 곳)
* **데이터 세그먼트** : 프로그램이 시작해서 끝날 때까지 계속 사용되는 데이터는 '데이터 세그먼트'에 보관된다.(데이터 저장)
* **스택 세그먼트 ** : '스택 세그먼트'는 프로그램 실행 중에 필요한 임시 데이터를 저장하는데 사용하는 메모리 영역이다. 스택 세그먼트는 지역 변수가 놓이는 스택과 동적으로 할당되는 메모리 공간인 힙으로 나뉩니다.

정적 메모리 할당은 일회성 상수같은거에 사용

---

##### 정적으로 할당된 메모리를 관리하는법

skip

---

### 지역 변수와 스택

##### 스택에 대하여
스택은 후입선출 정도만 알고 skip. 이런게 있다정도만. 초심자에게 어렵고 원래 많은 양인데 몇페이지로 될 게 아니다.

---

### 동적 메모리 할당 및 해제

##### 정적 메모리 할당의 한계

값이 변할 때마다 수정해야하고, 메모리 크기 제한있다(일정부분밖에 못씀)

---

##### 동적 메모리 할당

> malloc 함수로 동적 메모리를 할당하며(포인터로 해줘야 한다), void * 형식으로  반환해준다. void *를 사용하면 형변환(casting)을 해줘야 한다.

malloc 함수는 메모리 할당에 실패하는 경우도 있다! 이런 경우 malloc함수는 할당된 메모리 주소 대신에 NULL을 반환한다. 
따라서 malloc 함수가 메모리 할당에 실패하는 경우를 대비하여 다음과 같이 넘겨받은 주소가 NULL인지 체크하는것이 좋다

```c++
short *p = (short *)malloc(100);
if(p != NULL){
    //메모리 할당에 성공함. 이 시점부터 100바이트 메모리 사용 가능
}else{
    //메모리 할당에 실패
}
```

---

##### free함수로 할당된 메모리 해제하기(반드시 해줘야 한다!)

동적메모리에서 
언제 어떻게 할당받고 -> malloc 
언제 어떻게 해제해야 하는지 -> free(p) (p가 가지고 있는 주소에 할당된 메모리 해제)
두개는 셋트!

할당되지 않은 메모리를 해제하거나(malloc함수 선언 x),
정적으로 할당된 메모리를 해제하거나(malloc함수 선언 x),
할당된 메모리를 두 번 해제하는 경우
오류 발생

---

### 동적 메모리 사용하기

##### 정적 메모리 할당을 사용했을 때 발생할 수 있는 문제점

```c++
int data_size = 3;
int data[data_size]; //배열의 요소 개수는 상수만 명시! 오류발생
```

##### malloc 함수는 메모리 할당 크기를 변수로 지정 할 수 있다
```c++
int data_size = 12;
int *p = (int *)malloc(data_size); //12바이트의 메모리가 동적 할당됨
```

---

```c++
#include <malloc.h>

void main(){
    int *p_num_list, count = 0, sum = 0, limit = 0, i;
    
    printf("사용할 최대 개수를 입력하세요 : ");
    scanf("%d", &limit);

    p_num_list = (int *)malloc(sizeof(int)*limit);  //사용자가 입력한 개수만큼 정수를 저장할 수 있는 메모리를 할당

    while(count < limit){
        printf("숫자를 입력하세요 (9999를 누르면 종료) : ");
        scanf("%d", p_num_list + count);
        if(*(p_num_list + count) == 9999){
            break;
        }
        count++;
    }

    for(i = 0; i < count; i++){
        if(i > 0){
            printf(" + ");
        }
        printf("%d", *(p_num_list + i));
        sum = sum + *(p_num_list + i);
    }

    printf(" = %d\n", sum);
    free(p_num_list);
}
```

---

# 17. 다차원 포인터

##### 다차원 포인터란?

동훈아라고 직접 말하지 않고 친구야 또는 나의 친구야 같은 자신을 기준으로 대상을 가리키는 간접표현으로 여러 번 가리키는 포인터를 '다차원 포인터'라고 한다.

---

##### 다차원 포인터 정의하기

*이 하나면 1차원, *이 두개면 2차원 포인터라고 한다. 이 포인터 변수를 선언할 때 사용하는 * 키워드는 최대 7개(컴파일러마다 다름)까지 사용할 수 있으며, 왠만하면 3개이상 쓰지 마라.. 3차원도 많이 안씀

---

##### 일반 변수의 한계와 다차원 포인터

```c++
short data = 0;
int my_ptr = (int)&data; //&data는 short * 형식의 값을 가지기 때문에 int형 변수인 my_ptr에 저장하기 위해서 형변환한다. 4바이트 크기라서 정상적으로 주소 저장
*my_ptr = 3; //오류 발생. my_ptr은 포인터가 아니라서 * 연산자 사용 할 수 없다.
```

---

### 2차원 포인터

> 2차원 포인터는 1차원 포인터의 주소 값을 저장한다.

```c++
void main(){
    short data =3;
    short *p = &data;
    short **pp = &p; //1차원 포인터 p변수의 주소 값을 2차원 포인터 p에 저장

    printf("[before] data : %d\n", data);
    *p = 4;
    printf("[use *p] data : %d\n", data);
    **pp = 5;
    printf("[use **pp] data : %d\n", data);

}
```

★★★★★★★★★★★★★★★★★★★★★★★★★★★★★       
O - > 값(자신이 저장하는 값)      
** -> 직전 참조 pointer의 값      
*** -> 직전 참조 pointer가 가리키는 값       
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★      

예제) malloc 함수를 사용하여 2차원 포인터 구조 만들기
```c++
void main(){
    short **pp; //2차 포인터만 있기때문에 1차 포인터 공간 만들어줘야 함
    pp = (short **)malloc(sizeof(short *)); //1차 포인터 공간 만들어줌. 4바이트 할당. sizeof short*은 포인터공간이라 무조건 4바이트!. 앞에 short** 별 두개 붙은거는 pp가 2차포인터라서 맞춰줌
    *pp = (short *)malloc(sizeof(short)); //1차 포인터가 가리키는 실제 값 공간 만들어줌. 실제값이 저장되는 공간이라 sizeof 뒤에 별 안붙음. 앞에 short *별 하나 붙는거는 pp가 1차 포인터 별 1개붙은거라 맞춰줌.

    **pp = 10;
    printf("**pp : %d\n", **pp);
    free(*pp); //나중에 만든 것부터 지워야 함!
    free(pp);
}
```
