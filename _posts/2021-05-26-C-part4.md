---
layout: post

title: "C Part4. 시프트 연산자와 비트 연산자, 지역 변수와 전역 변수, extern·static·const 키워드"
excerpt: "시프트 연산자와 비트 연산자, 지역 변수와 전역 변수, extern·static·const 키워드"

categories:
  - C
tags:
  - [C]
  
toc: true
toc_sticky: true
 
date: 2021-05-24
last_modified_at: 2021-05-24
---


# 10. 시프트 연산자와 비트 연산자

### 비트 단위 연산과 비트 패턴

알면 좋고 모르면 불편한 정도. 가벼운 맘으로 강의 듣기~, but 하드웨어쪽은 필수!

* c언어의 가장 작은 자료형은 1바이트이다.
* 오른쪽에서 왼쪽으로 갈수록 비트 번호가 커진다.

---

##### 시프트 연산자

* 시프트 연산자(<<, >>)는 변수의 값을 지정한 비트 수만큼 왼쪽 또는 오른쪽으로 비트를 이동 시키는 기능을 합니다.
* 비트가 이동한 빈자리에는 0이 채워집니다.
* 변수에 부호가 있는 경우 -> 부호비트가 1이면 빈자리는 1로 채워진다
* 비트가 왼족으로 이동해서 사라지는것을 오버플로(Overflow)라 부르고, 오른쪽으로 이동해서 사라지는 것을 언더플로(Underflow)라고 부른다.
* 결론은 특수한 목적에서만 사용. 

---

##### 데이터 암호화하기
XOR(^) 연산자 사용..

---

# 11. 지역 변수와 전역 변수

### 지역변수(Local Variable)
* 함수 안에 선언한 변수나 매개변수는 지역변수이다.
* 자신을 선언한 함수가 호출 될 때 메모리에 저장공간이 만들어졌다가 함수 호출이 끝나면 함께 사라진다. <u>즉 함수와 같은 수명을 가진다.</u>
* 지역 변수 이름은 <u>서로 다른 함수에서 선언</u>된 변수라면 <u>중복해서 사용</u>할 수 있다.
* 지역변수는 스스로 초기화되지 않기 때문에 필요할 때 <u>프로그래머가 직접 초기화</u> 해야 한다.

```c++
int ReturnNum(){
    int num = 5;
    return num;
}
void main(){
    ReturnNum();
    printf("%d", num);
}
// 결과 -> 11행의 num이 선언되지 않은 함수라면서 오류 발생
```

```c++
int Sum(int data1, int data2){   //매개변수 data1, data2는 Sum함수의 지역변수
    int result = data1 + data2; //해당 result와 아래 result는 서로 다른 메모리에 할당되어 값이 공유되지 않는다.
    return result;
}
void main(){
    int result;
    result = Sum(5, 3); //해당 result와 위의 result는 서로 다른 메모리에 할당되어 값이 공유되지 않는다. 초기화 되지 않아 어떤 값이 들어있는지 모름
    printf("5 + 3 = %d", result);
}
```

---

### 전역변수(Global Variable)

* 이 변수는 프로그램이 시작할 때 만들어졌다가 프로그램이 종료될 때 사라진다. 따라서 <u>수명이 프로그램과 같다.</u>
* 전역 변수는 <u>특별한 초기화 값이 없으면 0으로 초기화</u> 된다.(프로그램마다 다르며 무조건 0으로 초기화되지 않는다.)
* 전역변수를 사용하면 <u>의존적</u>으로 바뀌게 된다. -> 예를들어 다른 프로그램에서 재사용하기 위해 코드를 복사하는 경우에는 변수 선언한것도 같이 옮겨야 하는데, 옮겨 갈 프로그램에 이미 같은 이름으로 선언된 변수가 있다면 하나는 이름을 바꿔야 한다.
* 전역 변수는 꼭 필요한 경우에만 사용하세요 -> 같은 이름의 전역변수를 사용하면 프로그램이 링크 될 때 중복 오류가 발생

---

##### 지역변수와 전역변수의 이름이 같다면?
두 변수는 성격이 달라서 오류로 처리되지 않으며, 지역을 우선해서 처리한다.

---

### extern 키워드

<u>같은 프로젝트 안에 존재</u>하는 <u>전역 변수를 참조</u>하겠다는 의미로 사용

```c++
//Sum.c
int result = 0; //전역변수

void Sum(int data1, int data2){
    result = data1 + data2;
}

//----------------------------------------------------------------------------------------------------------------------------------------

//Main.c
void Sum(int, int);   //함수 원형 선언
exturn int result;    //전역변수 참조 선언

void main(){
    Sum(5, 3);
    printf("5 + 3 = %d",result);
}
```

##### 사용시 주의할 점

프로젝트 p

| A.c  | B.c  |
|---|---|
| int g_data1 = 0;    <br />    int g_data2 = 0;    <br />    int g_data5 = 0;   | 1. int g_data1;    <br />    2. exturn int g_data2;    <br />    3. exturn int g_data3;    <br />    4. exturn int g_data4 = 0;    <br />    5. exturn int g_data5 = 0;  |

1. 오류 - >다른데서 이미 전역변수 선언해서 썼으니 너는 쓰지마
2. 정상
3. 오류 -> A.c에 선언되지 않은 전역변수를 참조하여 오류
4. 정상 -> exturn 참조할 때 초기화를 사용했기 때문에 처리된다.
5. 오류 -> A.c에서 이미 전역변수가 선언됐기 때문에 중복되었다고 오류

---

### static 키워드

* 해당 전역 변수의 사용 범위를 변수를 <u>선언한 소스 파일로 제한</u>

프로젝트 p

| A.c  | B.c  |
|---|---|
| int g_data1 = 0;    <br />    static int g_data2 = 0;     <br />    static int g_data3 = 0;  | 1. int g_data1;    <br />    2. int g_ data;     <br />    3. exturn int g_data3;  |

1. 오류 -> 같은 이름의 전역변수가 있기 때문에 오류
2. 정상 -> static으로 구별되어 별개의 전역변수로 처리
3. 오류 -> static이라 exturn으로 참조할 수 없기 때문에 오류

---

### const 키워드
* 변수를 상수처럼 쓰고싶을 때 사용.
* 변경이 안되게끔 잠궈준다.
* 변수의 값을 변경하지 않겠다는 의미.

---
