---
layout: post

title: "C Part1. 프로그램과 C언어(소스,목적,실행파일), 자료형(char, unsinged char, short, int, float, double), 상수(10진수, 8진수, 16진수, 2진수)와 변수"
excerpt: "프로그램과 C언어(소스,목적,실행파일), 자료형(char, unsinged char, short, int, float, double), 상수(10진수, 8진수, 16진수, 2진수)와 변수"

categories:
  - C
tags:
  - [C]
  
toc: true
toc_sticky: true
 
date: 2021-05-24
last_modified_at: 2021-05-24
---


# 01. 프로그램과 C언어
### C 프로그램 실행 파일

* **소스파일**은 프로그래머가 언어를 사용해서 작성한 파일.
* **목적파일**(기계어)은 컴파일러(번역기)가 소스파일을 번역(컴파일)하면 만들어지는 파일. 사용자가 직접 만들 필요는 없음.
* **실행파일**은 컴퓨터에서 실행할 수 있는 파일.     
<br />  

                  |             빌드            |
                  |    컴파일     |    링크     |
        | 소스파일(*.c) | 목적파일(*.obj) | 실행파일(*.exe) |

소스파일을 목적파일로 번역하는것을 **컴파일**이라 하고,
목적파일을 실행파일로 변환하는것을 **링크**라고 한다.
그리고 컴파일과 링크를 순차적으로 수행하는 것을 **빌드**라고 한다.


---
##### 목적파일을 두는 이유
* 소스파일을 번역해서 바로 실행파일을 만들면, 소스파일의 일부만 바뀌어도 소스파일 전체를 다시 번역해서 실행파일을 만들어야하기 때문에 비효율적. 
* <u>컴파일러가 실행 파일을 만드는 시간을 줄이기 위해 만드는 파일</u>.

---
##### 소스파일을 나누는 이유
C언어 컴파일러는 컴파일을 할 때 먼저 소스파일의 내용이 변경되었는지 체크한 후 변경되었으면 다시 컴파일하여 목적파일을 만들고, 변경되지 않았다면 이전의 목적파일을 재사용한다. 따라서 소스파일이 여러개로 나누어져 있을 때 소스파일의 일부가 바뀌었다면, 변경된 소스파일만 컴파일 되기 때문에 <u>컴파일 시간이 줄어드는 효과가 있다.</u>

---

<br />
# 03. 자료형

### 컴퓨터의 자료 기억방식

##### 부호비트를 사용하여 양수와 음수를 구별한다.
* 비트 8개 중 1개에 음수 또는 양수인지 상태를 저장하고 나머지 비트 7개에는 숫자를 저장한다. 여기서 양수와 음수를 구별하는 비트를 부호비트라고 한다.
* 7비트는 -128~127 사이의 숫자 중 하나를 저장.
* 음수일때는 1, 양수일때는 0을 부호비트에 저장.
<br />
* 부호를 고려하는 1바이트에서 각 비트의 값이 0 1 1 1 1 1 1 1 이라면 양수 최댓값을 의미하기 때문에 숫자 값은 127.
* 1 0 0 0 0 0 0 0 이라면 음수 최솟값을 의미하기때문에 숫자 값은 -128
* 1 1 1 1 1 1 1 1 이라면 숫자 값은 음수 최대값인 -1.


| 저장 공간 크기  | 비트 단위 환산  | 저장할 수 있는 숫자의 개수  |
|:---:|:---:|---|
| 1바이트  | 8비트  | 256개  |
| 2바이트  | 16비트  | 65,536(2 <sup>16</sup>)  |
| 4바이트  | 32비트  | 4,294,967,296(2 <sup>32</sup>)  |

---


### 자료형

* signed char(**char**) : 부호가 있는 1바이트 저장 공간. -128~127의 숫자 중 하나를 저장 할 수 있는 크기. 

* unsigned char(**unsigned char**) : 부호가 없는(양수) 1바이트 저장 공간. 0~255

* signed short int(**short**) : 부호가 있는 2바이트 저장 공간. -32,768~32767

* unsigned short int(**unsigned short**) : 부호가 없는 2바이트 저장 공간. 0~65,535

* signed long int(**int**) : 부호가 있는 4바이트 저장 공간. -2,147,483,648~2,147,483,647

* unsigned long int(**unsigned int**) : 부호가 없는 4바이트 저장 공간. 0~4,294,967,295. 
ex)1970년 1월 1일부터. 초는 - 없으니 unsigned 사용하며 signed 사용했으면 저장공간이 얼마 안남았음. 

---

##### 실수 자료형(소수점 자리의 값을 저장)
* **float** : 소수점 5자리까지 저장. 4바이트
* **double** : 소수점 그 이상 저장. 8바이트

---

<br />

# 04. 상수와 변수
### 상수

> 상수 : 상수는 항상 같은 수! 변하지 않는 숫자를 의미한다. ex)PI

* 8진수 : 숫자 앞에 0을 붙여서 적는다.
* 16진수 : 숫자 앞에 0x 또는 0X를 붙여서 적는다.

| 10진수  | 8진수  |  16진수 | 2진수  |
|:---:|:---:|:---:|:---:|
| 0  | 0  | 0  | 0000  |
| 1  | 1  | 1  | 0001  |
|  2 | 2  | 2  | 0010  |
| 3  | 3  | 3  | 0011  |
| 4  | 4  | 4  | 0100  |
| 5  | 5  | 5  | 0101  |
| 6  | 6  |  6 | 0110  |
| 7  | 7  |  7 | 0111  |
| 8  | 10  | 8  | 1000  |
| 9  | 11  | 9  | 1001  |
| 10  | 12  | A  | 1010  |
|  11 | 13  |  B | 1011  |
| 12  | 14  |  C | 1100  |
| 13  | 15  |  D | 1101  |
| 14  | 16  | E  | 1110  |
| 15  | 17  | F  | 1111  |

> * 2진수와 16진수는 4비트 단위로 나누어서 쉽게 변환 할 수 있다.
> * C언어는 2진법 표현을 제공하지 않는다.

---

##### 문자형 상수 ex) char key = 'A';

---

### 변수
> 변수 : 값이 바뀌는 정보, 저장공간
