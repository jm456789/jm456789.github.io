---
layout: post

title: "DB Chapter2 관계 데이터 모델 - 릴레이션의 개념 / 릴레이션 스키마와 인스턴스 / 릴레이션의 특징 / 관계 데이터 모델 / 키, 슈퍼키, 후보키, 기본키, 대리키, 대체키, 외래키 / 무결성 제약조건 / 관계대수 / 셀렉션과 프로젝션 / 집합연산(합집합, 교집합, 차집합, 카티션 프로덕트) / 조인(세타, 동등, 자연, 외부, 세미조인) / 디비전 / 관계대수 사용예제"
excerpt: "릴레이션의 개념 / 릴레이션 스키마와 인스턴스 / 릴레이션의 특징 / 관계 데이터 모델 / 키, 슈퍼키, 후보키, 기본키, 대리키, 대체키, 외래키 / 무결성 제약조건 / 관계대수 / 셀렉션과 프로젝션 / 집합연산(합집합, 교집합, 차집합, 카티션 프로덕트) / 조인(세타, 동등, 자연, 외부, 세미조인) / 디비전 / 관계대수 사용예제"

categories:
  - DataBase
tags:
  - [DataBase, DB]
  
toc: true
toc_sticky: true
 
date: 2021-07-02
last_modified_at: 2021-07-02
---

# Part1. 데이터베이스 시스템의 개념

# Chapter 02. 관계 데이터 모델

### 관계 데이터 모델의 개념

##### 릴레이션의 개념

릴레이션은 **관계 데이터 모델의 핵심적인 개념**으로 **행과 열로 구성된 테이블**을 말한다.

| 용어  | 한글 용어  |
|---|---|
| <u>relation</u>  | 릴레이션, **테이블**. 관계라고 하지 않음  |
| relational data model  | 관계 데이터 모델  |
| relational database  |  관계 데이터베이스 |
| relational algebra  | 관계대수  |
| <u>relationship</u>  | **관계**  |

---

##### 릴레이션 스키마와 인스턴스

<u>릴레이션</u>은 **스키마**와 **인스턴스**로 이루어진다. 스키마는 관계 데이터베이스의 릴레이션이 어떻게 구성되는지, 어떤 정보를 담고 있는지에 대한 기본적인 구조를 정의한다. <u>테이블</u>에서 **스키마는 테이블의 헤더**에 나타나며 각 데이터의 특징을 나타내는 속성, 자료타입 등의 정보를 담고있다. 인스턴스는 정의된 스키마에 따라 테이블에 실제로 저장되는 데이터의 집합을 의미한다.

<br />

![](https://github.com/jm456789/jm456789.github.io/blob/main/_images/db_day1_1.jpg?raw=true)

---

##### 릴레이션 스키마

릴레이션 스키마는 **릴레이션에 어떤 정보가 담길지 정의**한다.

* 속성(attribute) : 릴레이션 스키마의 열
* **도메인(domain)** : 속성이 가질 수 있는 값의 집합. 값의 영역. 범주. ex) 점수 100점 만점 시 0~100까지
* **차수(degree)** : 속성의 개수

---

##### 릴레이션 인스턴스

릴레이션 인스턴스는 **릴레이션 스키마에 실제로 저장된 데이터의 집합**이다. 

* 투플(tuple) : 릴레이션의 행
* 카디날리티(cardinality) : 투플의 수

---

##### 릴레이션 구조와 관련된 용어

| 릴레이션 용어  | 같은 의미로 통용되는 용어  | 파일 시스템 용어  |
|---|---|---|
| 릴레이션 \(relation\)  |  테이블 \(table\) | 파일 \(file\)  |
| 스키마 \(schema\)  | 내포 \(intension\)  | 헤더 \(header\)  |
| 인스턴스 \(instance\)  | 외연 \(extension\)  | 데이터 \(data\)  |
| 투플 \(tuple\)  |  행 \(row\) | 레코드 \(record\)  |
| 속성 \(attribute\)  |  열 \(column\) | 필드 \(field\)  |

---

##### 릴레이션의 특징

★★★★★기본!

* **속성은 단일 값을 가진다** : 각 속성의 값은 도메인에 정의된 값만을 가지며 그 값은 모두 단일값이어야 한다.
* **속성은 서로 다른 이름을 가진다** : 속성은 한 릴레이션에서 서로 다른 이름을 가져야만 한다.
* **한 속성의 값은 모두 같은 도메인 값을 가진다** : 한 속성에 속한 열은 모두 그 속성에서 정의한 도메인 값만 가질 수 있다.
* **속성의 순서는 상관없다** : 속성의 순서가 달라도 릴레이션 스키마는 같다.
* **릴레이션 내의 중복된 투플은 허용하지 않는다** : 하나의 릴레이션 인스턴스 내에서는 서로 중복된 값을 가질 수 없다. 즉 모둔 투플은 서로 값이 달라야 한다.
* **투플의 순서는 상관없다** : 투풀의 순서가 달라도 같은 릴레이션이다.

---

##### 관계 데이터 모델

관계 데이터 모델은 <u>데이터를 2차원 테이블 형태인 릴레이션으로 표현</u>하며 <u>릴레이션에 대한 제약조건과 관계연산을 위한 관계대수를 정의</u>한다.

**제약조건**은 각 릴레이션에 저장된 데이터 값이 가져야 하는 제약을 말한다. 예를들어 나이는 음수가 되면 안된다든지, 주문 릴레이션의 고객번호는 고객 리레이션에서만 참조해야한다든지 하는 규칙이다.

**관계연산**은 릴레이션을 다루는 연산규칙으로, 예를들면 주문 릴레이션과 고객 릴레이션 등을 조작하여 특정 고객의 주문 내역을 검색하는 행위를 의미한다.

---

### 무결성 제약조건

##### 키 (투플을 구분짓는)

* 키는 무엇인가를 유일하게 식별한다는 의미가 있다.
* <u>키가 되는 속성(혹은 속성의 집합)은 반드시 값이 달라서 투플들을 서로 **구별**할 수 있어야 한다.</u>
* <u>키는 릴레이션 간의 관계를 맺는 데도 사용</u>된다.

---

고객 테이블

| 고객번호  | 이름  | 주민번호  | 주소  |  핸드폰 |
|---|---|---|---|---|
| 1  | 박지성  | 810101-1111111  | 영국 맨체스터  | 000-5000-0001  |
| 2  |  김연아 | 900101-2222222  |  대한민국 서울 | 000-6000-0001  |
| 3  | 장미란  | 830101-2333333  | 대한민국 강원도  | 000-7000-0001  |
| 4  |  추신수 | 820101-1444444  |  미국 클리블랜드 | 000-8000-0001  |

키값으로 쓸 수 있는 것은 
고개번호, 주민번호, 고객번호+이름(결합), 고개번호+주민번호(결합)

---

##### 슈퍼키

슈퍼키는 **릴레이션 내 투플을 유일하게 식별**할 수 있는 하나의 속성 혹은 **속성의 집합**을 말한다.

* 고객번호 : 고객별로 유일한 값이 부여되어 있으므로 투풀을 식별할 수 있다.
* 이름 : 동명이인이 있으면 투플을 유일하게 식별할 수 없다.
* 주민번호 : 개인별로 유일한 값이 부여되어 있으므로 투플을 식별할 수 있다.
* 주소 : 가족끼리는 같은 정보를 사용하므로 투플을 식별할 수 없다.
* 핸드폰 : 한 사람이 여러 개의 핸드폰을 사용할 수 있고, 반대로 핸드폰을 사용하지 않는 사람이 있을 수 있으므로 투플을 식별할 수 없다.

핸드폰 번호가 없으면 데이터베이스에서는 값이 없다는 의미로 NULL 값을 사용한다.

---

##### 후보키

* 후보키는 **투플을 유일하게 식별할 수 있는 속성의 최소 집합**이다. (유일성 + 최소성) 
* 위의 테이블에서 슈퍼키 후보는 많지만 후보키는 <u>주민번호,  고객번호</u>만 될 수 있다. 
* <u>두 개 이상의 속성으로 이루어진 키를 복합키</u>라고 한다.

---

##### 기본키

* 기본키는 **여러 후보키 중 하나를 선정하여 대표로 삼는 키**를 말한다.
* 주민번호와 고객번호를 선택할 수 있다.
* 최근 개인정보 보호에 관한 관심이 높아지면서 주민번호같은 중요한 정보를 기본키로 사용하는 것은 부담되므로 고객번호를 기본키로 선택하는게 좋다.

---

##### 기본키 선정 시 고려사항

지금까지 내용을 토대로 기본키 선정 시 고려사항을 정리한다면 다음과 같다. 다음 고려사항 중 일부는 기본키 제약조건이라고 한다.

* 릴레이션 내 투플을 식별할 수 있는 고유한 값을 가져야 한다.
* NULL 값은 허용하지 않는다.
* 키값의 변동이 일어나지 않아야 한다.
* 최대한 적은 수의 속성을 가진 것이라야 한다.
* 향후 키를 사용하는 데 있어서 문제 발생 소지가 없어야 한다.

릴레이션 스키마를 표현할 때 <u>기본키는 밑줄을 그어 표시</u>한다.

---

##### 대리키

기본키가 보안을 필요로하거나, 여러개의 속성으로 구분되어 복잡하거나, 마땅한 기본키가 없을 때는 **일련번호 같은 가상의 속성을 만들어 기본키로 삼는 경우**가 있다. 이러한 키를 대리키 혹은 인조키라고 한다.

---

##### 대체키

대체키는 **기본키로 선정되지 않은 후보키**를 말한다. 고객 릴레이션의 경우 고객번호와 주민번호 중 고객번호를 기본키로 정하면 주민번호가 대체키가 된다.

---

##### 외래키

외래키는 **다른 릴레이션의 기본키를 참조하는 속성**을 말한다. 

* 관계 데이터 모델의 특징인 릴레이션간의 관계를 표현한다. 
* 외래키는 다른 릴레이션의 기본키를 참조하는 속성이다.
* 외래키가 성립하기 위해서는 참조하고 참조되는 양쪽 릴레이션의 도메인이 서로 같아야 한다.
* 참조되는 릴레이션의 기본키 값이 변경되면 이 기본키를 참조하는 외래키 값 역시 변경되어야 한다.
* 외래키는 참조되는 릴레이션의 기본키와 달리 NULL값을 포함할 수 있고 중복 값도 허용한다.
* 외래키 사용 시 참조하는 릴레이션과 참조되는 릴레이션이 꼭 다른 릴레이션일 필요는 없다. 즉 자기 자신의 기본키를 참조할 수 도 있다.
* 외래키가 기본키의 일부가 될 수 있다.

---

##### 무결성 제약조건

* **도메인 무결성 제약조건** : 도메인 제약이라고도 하며, **모든 투플은 릴레이션 스키마에 정의된 각 속성의 도메인에 지정된 값만을 가져야 한다**는 조건이다. (삽입 가능한 데이터 값을 제한). ex) 나이 음수 x.

* **개체 무결성 제약조건** : <u>기본키 제약</u>이라고도 한다. 릴레이션은 기본키를 지정하고 그에 따른 무결성 원칙, 즉 **기본키는 NULL값을 가져서는 안되며** 릴레이션 내에 **오직 하나의 값만 존재해야 한다**는 조건이다.

* **참조 무결성 제약조건** : <u>외래키 제약</u>이라고도 한다. 참조 무결성 제약조건은 **자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 같아**야 하며, **자식 릴레이션의 값이 변경될 때 부모 릴레이션의 제약을 받는다**는 것이다.

<br />

제약 조건의 정리

| 구분  | 도메인 무결성 제약조건  | 개체 무결성 제약조건      \(키\)  |  참조 무결성 제약조건 \(키\) |
|---|---|---|---|
| 제약 대상  |  속성 | 투플  | 속성과 투플  |
| 같은 용어  | 도메인 제약  | 기본키 제약  | 외래키 제약  |
| 해당되는 키  | -  |  기본키 | 외래키  |
| NULL값  |  허용 | 불가  | 허용  |
| 릴레이션 내 제약조건의 개수  | 속성의 개수와 동일  |  1개 | 0~여러 개  |
|  기타 | 투플 삽입/수정 시 제약사항 우선 확인  | 투플 삽입/수정 시 제약 사항 우선 확인  | 1. 투플 삽입/수정 시 제약사항 우선 확인      <br />     2. 부모 릴레이션의 투플 수정/삭제 시 제약사항 우선 확인  |

---

##### 무결성 제약조건의 수행

릴레이션은 데이터의 변경이 일어날 때 제약조건에 위배될 수 있다. 따라서 제약조건의 준수 여부는 데이터의 변경(삽입, 수정, 삭제)이 있을 때마다 확인해야 한다.

* **개체 무결성 제약조건**
관계 데이터베이스 시스템에서는 DBMS는 투플을 삽입하거나 수정할 때마다 개체 무결성 제약조건을 지키는 지 확인한다. 즉 기본키 값이 유일한지, NULL 값이 아닌지를 검사한다.

* **참조 무결성 제약조건**
참조 무결성 제약조건은 개체 무결성 제약조건과 달리 단일 릴레이션에 관한 내용이 아니다. 따라서 두 릴레이션간의 참조 관계에 따라 좀 더 복잡한 처리를 수행해야 한다.
**참조 무결성 제약조건을 수행하기 위한 네 가지 옵션은 RESTRICTED, CASCADE, DEFAULTE, NULL등이 있다.**

---

### 03. 관계대수

##### 관계대수

**관계대수**란 <u>릴레이션에서 원하는 결과를 얻기 위해 수학의 대수와 같은 연산을 이용하여 질의하는 방법을 기술하는 언어</u>이다. SQL 언어는 관계해석을 기반으로 하지만 DBMS 내부에서는 관계대수에 기반을 둔 연산을 수행하여 최종 결과 집합을 반환하게 된다. 

---

##### 관계대수 연산자

수학에서 연산자란 피연산자에 적용되는 연산기호를 말한다. 예를들어 2+3에서 2와 3은 피연산자이고, +는 연산자이다. 관계대수 연산자 역시 릴레이션 연산에 사용되는 기호로 릴레이션을 피연산자로 한다.

* 순수 관계연산(관계 데이터 모델을 위해 고안됨) : 셀렉션, 프로젝션, 조인, 디비전, 개명
* 일반 연산집합(수학의 집합이론에서 차용됨) : 합집합, 교집합, 차집합, 카티션 프로덕트

연산자 중 피연산자의 개수가 한 개인 연산자를 단항 연산자, 두 개인 연산자를 이항 연산자라고 한다. 또 관계대수 연산자는 기본 연산자 다섯 개와 기본 연산자로부터 유도가 가능한 유도 연산자로 구분한다.

---

##### 관계대수식

관계대수는 릴레이션 간 연산을 통해 결과 릴레이션을 찾는 절차를 기술한 언어이다. 관계대수 연산을 수행하기 위한 식을 관계대수식이라고 한다. 

* 단항 연산자 : 연산자<sub><조건></sub> 릴레이션
* 이항 연산자 : 릴레이션 1 연산자<sub><조건></sub> 릴레이션 2

관계대수식의 결과는 릴레이션으로 반환되며, 반환된 릴레이션은 릴레이션의 모든 특징을 따른다. 즉 중복된 투플은 존재하지 않는다. 만약 중복된 투플이 있으면 하나만 표시한다.

---

##### 관계대수식의 사용 예

R1)
| A  |  B | C  |
|---|---|---|
|  a1 | b1  | c1  |
| a2  | b3  | c3  |
|  a3 | b4  | c2  |

R2)
| A  |  B | C  |
|---|---|---|
|  a1 | b1  | c1  |
| a2  | b3  | c3  |
|  a3 | b3  | c1  |

> 셀렉션(σ)
> σ<sub>A=a1 or A=a2</sub> (R1)

| A  |  B | C  |
|---|---|---|
|  a1 | b1  | c1  |
| a2  | b3  | c3  |

R1에서 조건에 맞는 투플을 추출한다.

> 프로젝션(π)
> π<sub>A, B</sub> (R2)

| A  |  B |
|---|---|
|  a1 | b1  | 
| a2  | b3  | 
|  a3 | b3  | 

R2에서 조건에 맞는 속성만을 추출한다.

> 합집합(∪)
> R1 ∪ R2

| A  |  B | C  |
|---|---|---|
|  a1 | b1  | c1  |
| a2  | b3  | c3  |
|  a3 | b4  | c2  |
|  a3 | b3  | c1  |

R1과 R2의 합집합을 구한다.

> 차집합(-)
> R1 - R2

| A  |  B | C  |
|---|---|---|
|  a3 | b4  | c2  |

R1과 R2의 차집합을 구한다.

> 조인(⋈)
> R1 ⋈<sub>R1.C=R2.C</sub> R2

| R1.A  | R1.B  | R1.C  |  R2.A | R2.B  | R2.C  |
|---|---|---|---|---|---|
| a1  | b1  | c1  |  a1 | b1  |  c1 |
| a1  | b1  | c1  |  a3 | b3  |  c1 |
| a2  | b3  | c3  |  a2 | b3  |  c3 |

R1과 R2의 카티션 프로덕트를 구하여 조건에 맞는 투플을 추출한다.

---

### 셀렉션과 프로젝션

셀렉션과 프로젝션은 관계대수에서 가장 기본적인 연산으로 하나의 릴레이션을 대상으로 하는 단항 연산자이다. 연산의 결과 역시 하나의 릴레이션인데, 셀렉션은 대상 릴레이션에서 인스턴스의 일부, 즉 투플의 집합을 반환하며 프로젝션은 대상 릴레이션에서 지정된 속성값 일부를 반환한다. 

---

##### 셀렉션

셀렉션은 단어 그대로 <u>릴레이션의 투플을 추출하기 위한 연산</u>이다.
결과 릴레이션의 차수는 대상 릴레이션과 동일하고 카디날리티는 대상 릴레이션보다 작거나 같다. 조건으로는 '<속성>=<상숫값 또는 속성>'형태가 올 수 있고 R은 릴레이션을 나타낸다.

> σ<sub><조건></sub> (R)

질의)
마당서점에서 판매하는 도서 중 8,000원 이하인 도서를 검색하시오.

> 풀이 > σ<sub>가격<=8000</sub> (도서)

조건이 여러개라면 ∧(and) ∨(or) ￢(not) 기호를 이용하여 표현 할 수 있다. 예를들어 '가격이 8,000원 이하이고 도서번호가 3 이상인 도서'를 검색하려면 σ<sub>가격<=8000 ∧ 도서번호 >= 3</sub> (도서)

---

##### 프로젝션

프로젝션은 <u>릴레이션의 속성을 추출하기 위한 연산으로 단항 연산자</u>이다. 결과 릴레이션의 차수는 대상 릴레이션의 차수보다 작거나 같고 카디날리티는 동일하다.

> π<sub><속성리스트></sub> (R)

질의)
신간도서 안내를 위해 (이름, 주소, 핸드폰)의 카탈로그 주소록을 만드시오.

> 풀이 > π<sub>이름, 주소, 핸드폰</sub> (고객)

---

### 집합연산

합집합, 교집합, 차집합, 카티션 프로덕트는 기본 연산자이고, 교집합은 기본 연산자로 정의가 가능한 유도된 연산자이다. 
집합 연산자는 두 개의 릴레이션을 대상으로 하는 이항 연산자이다. 카티션 프로덕트를 제외한 합집합, 교집합, 차집합은 두 릴레이션의 차수 및 도메인과 속성의 순서가 동일해야 한다. 즉, 각 릴레이션의 속성 수가 같고 순서도 같아야 하며 각각 동일한 도메인으로 대응되어야 한다. 이 조건을 합병가능이라고 한다. 관계대수의 집합연산은 합병가능해야 성립된다. 이때 속성 이름은 동일하지 않아도 되며, 반환되는 릴레이션의 속성 이름은 첫 번째 릴레이션의 이름과 같다.

<u>수학의 집합연산과 동일한 방법으로 합집합, 교집합, 차집합, 카티션 프로덕트 등이 있다.</u>

---

##### 합집합(중복 허용 x)

두 개의 릴레이션은 서로 같은 속성 순서와 도메인을 가져야 한다. 반환되는 결과는 첫 번째 릴레이션의 속성 이름을 가진다. 작성 형식은 다음과 같다. R과 S는 릴레이션을 나타낸다.

> R ∪ S

질의)
마당서점은 지점 A와 지점 B가 있다. 두 지접의 도서는 각 지점에서 관리하며 릴레이션 이름은 각각 도서A, 도서B이다. 마당서점의 도서를 하나의 릴레이션으로 보이시오.

> 도서A ∪ 도서B

---

##### 교집합

교집합 역시 합병가능한 <u>두 릴레이션을 대상</u>으로 하며, 두 릴레이션이 <u>공통으로 가지고 있는 투플을 반환</u>한다.

> R ∩ S

질의)
마당서점의 두 지점에서 동일하게 보유하고 있는 도서 목록을 보이시오.

> 도서A ∩ 도서B

---

##### 차집합

차집합은 첫 번째 릴레이션에는 속하고 두 번째 릴레이션에는 속하지 않는 투플을 반환한다.

> R - S

질의)
마당서점의 두 지점 중 지점 A에서만 보유하고 있는 도서 목록을 보이시오.

> 도서A - 도서B

---

##### 카티션 프로덕트

지금까지의 집합연산이 두 릴레이션의 수직적 연산이었다면 카티션 프로덕트는 수평적 연산이다. 카티션 프로덕트는 <u>두 릴레이션</u>을 연결시켜 하나로 합칠 때 사용한다. 결과 릴레이션은 첫 번째 릴레이션의 오른쪽에 두 번째 릴레이션의 모든 투플을 순서대로 배열하여 반환한다. 속성과 도메인이 같을 필요는 없다. 결과 릴레이션의 차수는 두 릴레이션의 차수의 합이며, 카디날리티는 두 릴레이션의 카디날리티의 곱이다. 예를 들어 첫 번째 릴레이션의 차수가 4, 카디날리티가 3이고 두 번째 릴레이션의 차수가 5, 카디날리티가 4라면 결과 릴레이션의 차수는 9(4+5), 카디날리티는 12(3x4)가 된다. 

만약 두 릴레이션이 동일한 속성 이름을 가지고 있으면 충돌 할 수도 있다. 이 때는 결과 릴레이션의 속성 이름을 '<릴레이션 이름>.<속성 이름>'의 형태로 표현하거나 순서(위치)를 사용하여 표현한다.

> R x S

질의)
고객 릴레이션과 도서 릴레이션의 카티션 프로덕트를 구하시오(결과 개수가 많으므로 투플을 일부 삭제한 릴레이션을 사용한다).

> 고객 x 주문

카티션 프로덕트는 두 릴레이션을 무조건 수평으로 합친 결과를 반환하기 때문에 결과에 의미가 없으며, 대부분 유용한 자료로 활용하기 힘들다. 이때 셀렉션과 프로젝션 연산을 조합하여 사용하면 유용하다. 의미있는 투플을 찾아내는 작업은 조인에서 배운다.

---

### 조인

조인은 <u>두 릴레이션의 공통 속성을 기준으로 속성값이 같은 투플을 수평으로 결합하는 연산</u>이다. 즉 두 릴레이션을 카티션 프로덕트 연산을 한 후 셀렉션 연산을 한 것으로 정의할 수 있다. 두 개의 릴레이션을 대상으로 하는 이항 연산자이다.

R과 S는 릴레이션이며 c는 조인 조건을 나타낸다. 오른쪽 식은 기본 연산자로 조인 연산을 표현한 것으로, 조인 연산은 카티션 프로덕트 연산에 조인 조건을 적용한 것과 같다.

> R ⋈ <sub>c</sub> S = σ<sub>c</sub>(RxS)

조인을 수행하기 위해서는 두 릴레이션의 조인에 참여하는 속성이 서로 동일한 도메인으로 구성되어야 한다. 조인 연산의 결과는 공통 속성의 속성값이 동일한 투플만을 반환한다.

---

### 세타조인과 동등조인

##### 세타조인

세타조인은 조인에 참여하는 <u>두 릴레이션의 속성값을 비교하여 조건을 만족하는 투플만 반환</u>한다. 세타조인의 조건은 {=, ≠, ≧, ≦, <, >}중 하나가 된다.

작성 형식은 다음가 같다. R과 S는 릴레이션이며 r은 R의 속성, s는 S의 속성을 나타낸다.

> R ⋈ <sub>(r 조건 s)</sub> S

---

##### 동등조인

동등조인은 <u>세타조인에서 = 연산자를 사용한 조인</u>을 말한다. **보통 조인 연산이라고 하면 동등조인을 지칭**한다. 

> R ⋈ <sub>(r=s)</sub> S

질의 )
고객과 고객의 주문 사항을 모두 보이시오.

> 고객 ⋈ <sub>(고객.고객번호=주문.주문번호)</sub> 주문

**일치하는 내용만 결합**

p104 표 참조

---

##### 자연조인

자연조인은 <u>동등조인에서 조인에 참여한 속성이 두 번 나오지 않도록</u> 두 번째 속성을 제거한 결과를 반환한다. 자연조인의 결과 차수는 '두 릴레이션의 차수의 합 -1'이다.
(중복되는 속성 제거. 제대로 된 조인?)

<u>조인에 참여한 속성이 두 번 나오지 않도록 중복된 속성을 제거한 결과를 반환한다.</u>

> R ⋈ <sub>N(r, s)</sub> S

질의)
고객과 고객의 주문 사항을 모두 보여 주되 같은 속성은 한 번만 표시하시오.

> 고객 ⋈ <sub>N(고객.고객번호, 주문.고객번호)</sub> 주문

P105 표 참조

---

### 외부조인과 세미조인

##### 외부조인

외부조인은 자연조인의 확장된 형태이다. 외부조인은 <u>자연조인 시 조인에 실패한 투플을 모두 보여주되 값이 없는 대응 속성에는 NULL값을 채워서 반환</u>한다.

* 왼쪽<sub>left</sub> 외부조인 : R ⟕ <sub>(r, s)</sub> S
* 완전<sub>full</sub> 외부조인 : R ⟗ <sub>(r, s)</sub> S
* 오른쪽<sub>right</sub> 외부조인 : R ⟖ <sub>(r, s)</sub> S

질의)
마당서점의 고객과 고객의 주문 내역을 보이시오.
 1. 고객 기준으로 주문 내역이 없는 고객도 모두 보이시오.
 2. 주문 내역이 없는 고객과 고객 릴레이션에 고객번호가 없는 주문을 모두 보이시오.
 3. 주문 내역 기준으로 고객 릴레이션에 고객번호가 없는 주문도 모두 보이시오.

 > 고객 ⟕ <sub>(고객.고객번호, 주문.고객번호)</sub> 주문
 > 고객 ⟗ <sub>(고객.고객번호, 주문.고객번호)</sub> 주문
 > 고객 ⟖ <sub>(고객.고객번호, 주문.고객번호)</sub> 주문

 p107 표 참조

 ---

 ##### 세미조인
 
 세미조인은 <u>자연조인을 한 후 두 릴레이션 중 한쪽 릴레이션의 결과만 반환</u>한다.
 (세미조인은 릴레이션이 줄어든다. 앞에꺼는 다 늘어남.)

 세미조인은 기호에서 <u>닫힌 쪽 릴레이션의 투플만 반환</u>한다.

 p108 참조

 ---

 ### 디비전

 디비전은 다른 연산과 달리 릴레이션의 속성값의 집합으로 연산을 수행한다. 
 디비전 연산은 특정 값들을 모두 가진 투플을 찾을 때 사용한다. 그러나 실제로 자주 사용되지 않으며 조인 연산을 이용하여 디비전 연산을 수행할 수 있다.

 <u>속성 A와 B로 이루어진 릴레이션 R과 속성 B로 이루어진 릴레이션 S의 디비전 연산은, 릴레이션 S의 속성 B값과 서로 동일하게 대응하는 릴레이션 R의 속성 A의 투플들을 반환한다.</u>

 > R ÷ S

 ---

 ### 관계대수 사용예제

 관계대수식은 연산자 하나만 단독으로 사용하는 경우는 드물고, 여러 연산자를 복합하여 사용하는 경우가 많다. 예를들어 카티션 프로덕트의 경우 의미 없는 결과를 반환하므로 프로젝션과 셀렉션 연산을 조합해서 사용한다.

 다음은 셀렉션, 프로젝션, 집합연산을 복합하여 사용

 질의)
 마당서점의 도서 중 가격이 8,000원 이하인 도서이름과 출판사를 보이시오.

 > 마당서점의 지점이 하나인 경우
 > π <sub>도서이름, 출판사</sub> (σ<sub>가격<=8000</sub> 도서)
 > p110 표 참조

 > 마당서점의 지점이 둘 이상인 경우
 > π <sub>도서이름, 출판사</sub> ((σ<sub>가격<=8000</sub> 도서 A) ∪ (σ<sub>가격<=8000</sub> 도서 B))
 > p111 표 참조

---

다음은 카티션 프로덕트와 조인을 사용한 연산이다 (방법은 동등조인 방법도 ok. 자연조인도)

질의)
마당서점의 박지성 고객의 거래 내역 중 주문번호, 이름, 가격을 보이시오.

> π <sub>주문.주문번호, 고객.이름, 주문.판매가격</sub> (σ<sub>고객.고객번호=주문.고객번호 AND 고객.이름='박지성'</sub> (고객 X 주문))
> p112 표 참조

같은 질의를 조인을 사용하여 간결한 식으로 만든다.

> π <sub>주문번호, 이름, 판매가격</sub> (σ<sub>이름='박지성'</sub> (고객 ⋈ <sub>고객.고객번호=주문.주문번호</sub> 주문))
> p113 표 참조

---