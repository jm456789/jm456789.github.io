---
layout: post

title: "DB-Day4 2021-06-14. "
excerpt: "SQL 소개(SELECT, FROM, WHERE), 조건 검색, 집합, 패턴, 집계 함수와 GROUOP BY 검색, HAVING, 두 개 이상 테이블에서 SQL 질의(조인), 부속질의, 집합연산, EXISTS, CREATE문, ALTER문"

categories:
  - DataBase
tags:
  - [DataBase, DB]
  
toc: true
toc_sticky: true
 
date: 2021-06-20
last_modified_at: 2021-06-20
---

### DROP 문

DROP은 테이블을 삭제하는 명령. <u>테이블의 구조와 데이터를 모두 삭제</u>하므로 사용에 주의해야 한다.

```c++
DROP TABLE NewBook;
```

삭제하려는 테이블의 기본키를 다른 테이블에서 참조하고 있다면, 참조하는 테이블부터 삭제해야 한다.

---

### 데이터 조작어 - 삽입, 수정, 삭제

### INSERT 문

INSERT문은 <u>테이블에 새로운 투플을 삽입</u>하는 명령이다.

질의 3-45)
Book 테이블에 새로운 도서 '스포츠 의학'을 삽입하십시오. 스포츠의학은 한솔의학서적에서 출간했으며 가격은 미정이다.

```java
INSERT INTO Book(bookid, bookname, publisher)
      VALUESE(14, '스포츠 의학', '한솔의학서적');
```

INSERT문은 SELECT문을 사영하여 한꺼번에 여러개의 투플을 삽입할 수 있다.

질의 3-46)
수입도서 목록(Import_book)을 Book테이블에 모두 삽입하십시오.

```c++
INSERT INTO Book(bookid, bookname, price, publisher)
        SELECT bookid, bookname, price, publisher
        FROM Imported_book;
```

---

### UPDATE 문

<u>기존 투플에 있는 특정 속성값을 수정</u>하는 명령이다.

질의 3-47)
customer 테이블에서 고객번호가 5인 고객의 주소를 '대한민국 부산'으로 변경하시오.

```c++
UPDATE Customer
SET address='대한민국 부산'
WHERE custid=5;
```

다른 테이블의 속성값을 이용할 수도 있다.

질의 3-48)
customer 테이블에서 박세리 고객의 주소를 김연아 고객의 주소로 변경하시오

```c++
UPDATE Customer
SET address=(SELECT address
              FROM Customer
              WHERE name='김연아')
WHERE name='박세리';
```

update문에서 여러 속성값을 한꺼번에 수정하는 작업은 가능하나, 잘못 사용하면 위험하다.

---

### DELETE 문

<u>테이블에 있는 기존 투플을 삭제</u>하는 명령이다.

```c++
DELETE FROM Customer
WHERE custid=5;

SELECT *FROM Customer;
```

위 SQL문에서 WHERE절을 빼면 고객 테이블의 모든 투플이 삭제되고 빈 테이블만 남는다.

```c++
DELETE FROM Customer;
```

위 SQL문은 실행되지 않는다. 그 이유는 Orders 테이블에서 Custid.custid 속성을 외래키로 참조하고 있가 때문이다. 

---

### COMMIT 문과 ROLLACK 문

이번 절에서 배운 insert, delete, update문의 결과는 최종적으로 commit문을 만나지 않으면 실제로 데이터베이스에 반영되지 않는다. 예를 들어 다음 문장을 실행하면 임시적으로 5번 고객이 삭제된다.

```c++
DELETE FROM Customer
WHERE custid=5;
```

이때 일시적으로 반영된 데이터를 복원시키려면 ROLLBACK 명령어를 사용한다.

```c++
ROLLBACK;
SELECT *FROM Customer;
```

이번에는 다시 삭제 작업을 실행해 보고 COMMIT 명령어로 데이터베이스에 삭제 작업을 반영시켜 본다.

```c++
DELETE FROM Customer
WHERE custid=5;
COMMIT;
```

반영 후에는 ROLLBACK 작업을 수행해도 삭제된 데이터의 복원이 불가능하다.

```c++
ROLLBACK;
SELECT * FROM Customer;
```

---

### SQL 고급

### SQL 내장 함수

SQL 내장함수는 <u>사용자가 만든 함수에 대비되는 용어로 DBMS에서 제공하는 함수이다. 상수나 열이름을 입력값으로 받아 호출되며, 단일 값을 결과로 반환</u>한다. 모든 내장함수는 최초에 선언 될 때 유효한 입력값을 받아야 한다. 예를 들어 수학 함수의 입력값은 정수 또는 실수여야 한다. SELECT 절과 WHERE 절, UPDATE 절 등에서 모두 사용할 수 있다.

##### 숫자 함수의 종류

| 함수  | 설명  | 예  |
|---|---|---|
| ABS(숫자)  |  숫자의 절댓값 계산 | ABS(-4.5) = 4.5  |
| CEIL(숫자)  |  숫자보다 크거나 같은 최대의 정수 |  CEIL(4.1) = 5 |
| FLOOR(숫자)  | 숫자보다 작거나 같은 최소의 정수  |  FLOOR(4.1) = 4 |
| ROUND(숫자, m)  | m 자리를 기준으로 숫자 반올림  | ROUND(5.36, 1) = 5.4  |
| LOG(n, 숫자)  |  숫자의 자연로그 값 반환 | LOG(10) = 2.30259  |
| POWER(숫자, n)  | 숫자의 n제곱 값 계산  | POWER(2, 3) = 8  |
| SQRT(숫자)  | 숫자의 제곱근 값 계산(숫자는 양수) | SQRT(9.1) = 3.0  |
| SING(숫자)  | 숫자가 음수이면 -1, 0이면 0, 양수이면 1  | SING(3.45) = 1  |

질의 4-2)
4.875를 소수 첫째 자리까지 반올림한 값을 구하시오.

```c++
SELECT ROUND(4.875, 1)
FROM dual;

//결과는 4.9
```

dual은 실제로 존재하는 테이블이 아니라 오라클에서 일시적인 연산 작업에 사용하기 위해 만든 가상의 테이블이다.

 1  &nbsp;&nbsp;&nbsp; 2 &nbsp;&nbsp;&nbsp; 3 &nbsp; . &nbsp; 4 &nbsp; 5 &nbsp; 6 &nbsp; 7
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
-3 &nbsp; -3 &nbsp; -1 &nbsp; 0 &nbsp; 1 &nbsp; 2 &nbsp; 3 &nbsp; 4  

에서 반올림 한다고 생각!

---

### 문자 함수

##### 문자 함수의 종류 : 문자값 반환 함수(s는 문자열, c는 문자, n과 k는 정수)

| 함수  | 설명  | 예  |
|---|---|---|
| CHR(k)  | 정수 아스키코드를 문자로 변환  | CHR(68) = 'D'  |
| CONTACT(s1, s2)  | 두 문자열을 연결  | CONTACT('마당', '서점') = '마당서점'  |
| INITCAP(s)  | 문자열의 첫 번째 알파벳을 대문자로 변환  | INITCAP('the sopa') = 'The Sopa'  |
| LOWER(s)  | 대상 문자열을 모두 소문자로 변환  | LOWER('MR. SCOTT') = 'mr. scott' |
| LPAD(s, n, c)  | 대상 문자열의 왼쪽부터 지정한 자릿수까지 지정한 문자로 채움  | LPAD('PAGE 1', 10, '*') = '****PAGE 1'  |
| LTRIM(s1, s2)  | 대상 문자열의 왼쪽부터 지정한 문자들을 제거  | LTRIM('<==>BBB<==>', '<>=') = 'BBB<==>'  |
| REPLACE(s1, s2, s3)  | 대상 문자열의 지정한 문자를 원하는 문자로 변경 | REPLACE('JACK and JUE', 'J', 'BL') = 'BLACK and BLUE'  |
| RPAD  |   |   |
| RTRIM  |   |   |
| SUBSTR(s, n, k)   |  대상 문자열의 지정된 자리에서부터 지정된 길이만큼 잘라서 반환 | SUBSTR('ABCDEFG', 3, 4) ='CDEF'  |
| TRIM(c FOME s)  |   |   |
| UPPER(s)  | 대상 문자열을 모두 대문자로 변환 |   |
| ASCII(c)  | 대상 알파벳 문자의 아스카코드 값을 반환  |  ASCII('D') = 68 |
| INSERT(s1, s2, n, k)  | 문자열 중 n번째 문자부터 시작하여 찾고자 하는 문자열 s2가 k번째 나타나는 문자열 위치 반환, 예제에서 3번째부터 OR가 2번째 나타나는 자릿수   | INSERT('CORPORATE FLOOR', 'OR', 3, 2) = 14 |
| LENGTH(s)  |  대상 문자열의 글자 수 를 반환 | LENGTH('CANDIDE') = 7  |

---

##### REPLACE 함수

실수로 도서 제목을 잘못 입력한 경우 일일이 변경하지 않고 한꺼번에 변경할 수 있다.

---
##### LENGTH 함수

주의할 점은 세는 단위가 바이트가 아니라 문자라는 점이다. 일반적으로 영문자 'A'는 1바이트, 한글 '가'는 2바이트(유니코드에서는 3바이트)지만 LEN 함수는 영문자나 한글이나 결과를 1로 반환한다. 또한 공백도 하나의 문자로 간주한다. 참고로 LENGTHB 함수를 사용하면 모두 바이트 단위로 반환한다.

---

질의 4-6)
마당서점의 고객 중에서 같은 성을 가진 사람이 몇 명이나 되는지 성별 인원수를 구하시오.

```c++
SELECT SUBSTR(name, 1, 1) "성", COUNT(*) "인원"
FROM Customer
GROUP BY SUBSTR(name, 1, 1);

//결과
//성  인원
//장  1
//김  1
//추  1
//박  2
```

---

### 날짜, 시간 함수

| 함수  | 설명  | 예  |
|---|---|---|
| TO_DATE(char, datetime)  | 문자형(CHAR)데이터를 DATE 형으로 반환  | TO_DATE('2020-09-14', 'yyyy-mm-dd') = 2020-09-14  |
| TO_CHAR(date, datetime)  |  DATE형 데이터를 문자열(CARTCHAR2)로 반환 | TO_CHAR(TODATE('2020-09-14', 'yyyy-mm-dd'), 'yyyymmdd') = '20200914'  |
| ADD_MONTHS(date, 숫자)  | 날짜에 지정한 달을 더해 DATE 형으로 반환(1:다음달, -1:이전 달)  | ADD_MONTHS(TO_DATE('2020-09-14', 'yyyy-mm-dd'), 12) = 2021-09-14  |
| LAST_DAY(date)  | 날짜에 달의 마지막 날을 DATE형으로 반환  | LAST_DAY(TO_DATE('2020-09-14', 'yyyy-mm-dd')) = 2020-09-30  |

질의 4-7)
마당서점은 주문일로부터 10일 후 매출을 확정한다. 각 주문의 확정일자를 구하시오.

```c++
SELECT orderid "주문번호", orderdate "주문일", orderdate+10 "확정"
FROM Orders;

//결과
//주문번호  주문일        확정
//1       20/07/01     20/07/11
```

---

##### datetime의 주요 인자

p.217 테이블 생략,, 힘듬

---

### NULL 값 처리

아직 지정되지 않은 값을 말한다. 값을 알수도 없고 적용할수도 없다는 뜻이다. NULL은 '0', '(빈문자)', ''(공백) 등과 다른 특별한 값이다. 또한 비교연산자로 비교할 수 없다. NULL값에 연산을 적용하면 결과는 NULL로 반환한다.

##### NULL 값을 확인하는 방법 - IS NULL, IS NOT NULL

WHERE 에 price='';를 넣으면 안됌. 오류임.
WHERE 에 price IS NULL; 이 사용 가능.

---

### NVL 함수

NULL 값을 다른 값으로 대치하여 연산하거나 다른 값으로 출력.

SELECT name "이름", NVL (phone, '연락처없음') "전화번호"

---

### ROWNUM

오라클 내장함수는 아니지만 자주 사용되는 문법이다. 오라클 내부적으로 생성되는 가상 칼럼으로 SQL 조회 결과의 순번을 나타낸다. 자료를 일부분만 확인하여 처리할 때 유용하다.

질의 4-11)
고객목록에서 고객번호, 이름, 전화번호를 앞의 두 명만 보이시오.

```c++
SELECT ROWNUM "순번", custid, name, phone
FROM Customer
WHERE ROWNUM <=2

//결과
//두줄만 보임..
```

---

### 부속질의

하나의 SQL문 안에 다른 SQL문이 중첩된 형태로 표현되는 질의를 말한다. <u>다른 테이블에서 가져온 데이터로 현재 테이블에 있는 정보를 찾거나 가공하는 데 사용한다.</u>
부속질의는 위치와 역할에 따라 SELECT 부속질의(스킬라 부속질의), FROM 부속질의(인라인 뷰), WHERE 부속질의(중첩질의)로 구분된다. 보통 부속질의라고 하면 WHERE 부속질의를 말한다. 부속질의들 간에 구분이 필요할 경우 WHERE 부속질의를 중첩질의라고 부르기도 한다.

* 스킬라 부속질의 :  SELECT 절에서 사용되는 부속질의로 단일행, 단일열의 스칼라값을 반환한다.
* 인라인 뷰 : FROM 절에서 사용되는 부속질의로 결과를 뷰(view)형태로 반환한다.
* 중첩질의 : WHERE 절에서 사용되는 부속질의로 주 질의에 사용된 자료 집합의 조건을 서술한다.

P.226~227 필기 보기,,

---

### IN, NOT IN

집합연산자 중 IN은 주 질의의 속성값이 부속질의에서 제공한 결과 집합에 있는지 확인하는 역할을 한다. IN연산자에서 사용 가능한 부속질의는 결과로 다중 행, 다중 열을 반환 수 있다.

---

### ALL, SOME(ANY)

ALL, SOME(ANY) 연산자는 비교 연산자와 함께 사용된다. <u>ALL은 모든</u>, <u>SOME은 어떠한(최소한 하나라도)</u>라는 의미를 가진다. 

질의 4-15)
3번 고객이 주문한 도서의 최고 금액보다 더 비싼 도서를 구입한 주문의 주문번호와 금액을 보이시오.

```c++
SELECT orderid, saleprice
FORM Orders
WHERE saleprice > ALL (SELECT saleprice
                        FROM Orders
                        WHERE custid='3');
```

---

### EXISTS, NOT EXISTS

데이터의 존재 여부를 확인한다.

질의 4-16)
EXISTS 연산자를 사용하여 '대한민국'에 거주하는 고객에게 판매한 도서의 총판매액을 구하시오.

```c++
SELECT SUM(saleprice) "total"
FROM Orders od
WHERE EXISTS (SELECT *
              FROM Customer cs
              WHERE address LIKE '%대한민국%' AND cs.custid=od.custid);
```

---

이후부터는 나중에??
CHAPTER 05 데이터베이스 프로그래밍(01. 데이터베이스 프로그래밍 방법, 02. PL/SQL, 03. 데이터베이스 연동 자바 프로그래밍, 04. 데이터베이스 연동 웹 프로그래밍) 건너뜀.

---

# 06. 데이터 모델링

### 데이터 모델링의 개념

##### 데이터베이스 생명주기

1. **요구사항 수집 및 분석** : 사용자들의 요구사항을 듣고 분석하여 데이터베이스 구축의 범위를 정하는 단계이다. 마당 서점의 경우 고객, 운영자, 경영자 등 사용자의 범위와 서비스 수준을 정하는 것을 말한다.
2. **설계** : 분석된 요구사항을 기초로 주요 개념과 업무 프로세스 등을 식별하고(개념적 설계), 사용하는 DBMS의 종류에 맞게 변환(논리적 설계)한 후, 데이터베이스 스키마를 도출(물리적 설계)한다.
3. **구현** : 설계단계에서 생성한 스키마를 DBMS에 적용하여 테이블 및 관련 객체(뷰, 인덱스 등)를 만든다. 또한 관련 소프트웨어에 설계한 데이터베이스를 적용하여 서비스를 제공할 수 있도록 프로그램을 완성한다.
4. **운영** : 구현된 데이터베이스를 기반으로 소프트웨어를 구축하여 서비스를 제공한다.
5. **감시 및 개선** : 데이터베이스 운영에 따른 시스템의 문제를 간찰하고 데이터베이스 자체의 문제점을 파악항 개선한다. 이 단계에서는 데이터베이스가 지속적으로 운영될 수 있도록 변경 및 유지보수를 한다.

---

##### 개념적 모델링

개념적 모델링은 <u>요구사항을 수집하고 분석한 결과를 토대로 업무의 핵심적인 개념을 구분하고 전체적인 뼈대를 만드는 과정</u>이다. 여기서 핵심적인 개념을 구분한다는 것은 <u>개체를 추출하고 각 개체 간의 관계를 정의하여 ER다이어그램을 만드는 과정</u>까지를 말한다.

##### 논리적 모델링

논리적 모델링은 <u>개념적 모델링에서 만든 ER 다이어그램을 사용하고자 하는 DBMS에 맞게 사상(매핑)하여 실제 데이터베이스로 구현하기 위한 모델을 만드는 과정</u>이다.

1. 개념적 모델링에서 추출하지 않았던 상세 속성들을 모두 추출한다.
2. 정규화를 수행한다. : 여러 개체가 데이터를 중복 저장하는 문제를 해결하기 위해 정규화를 수행한다.
3. 데이터의 표준화를 수행한다. : 데이터 용어 사전과 도메인을 정의하여 동일하게 사용되는 용어를 정리하고 데이터의 형태 및 크기 등을 확정한다.

##### 물리적 모델링

물리적 모델링은 <u>작성된 논리적 모델을 실제 컴퓨터 저장 장치에 저장하기 위해 데이터 타입과 길이 등 물리적 구조를 정의하고 구현하는 과정</u>이다.

다음은 물리적 모델링을 할 때 트랜잭션, 저장공간 설계 측면에서 고려해야 할 사항이다.

1. 응답시간을 최소화해야한다.
2. 얼마나 많은 트랜잭션을 동시에 발생시킬 수 있는지 검토해야 한다.
3. 데이터가 저장될 공간을 효율적으로 배치해야한다.

---

### ER 모델

ER 모델은 세상의 <u>사물을 개체와 개체간의 관계로 표현</u>한다. 개체는 독립적인 의미를 지닌 유무형의 사람 또는 사물을 말하며, 개체의 특성을 나타내는 속성으로 식별한다. 또한 개체끼리는 서로 관계를 맺는다. 이처럼 개체, 속성, 관계를 규명하는 것이 ER 모델의 기본이다.

---

### 개체와 개체 타입

**개체**는 <u>사람, 사물, 장소, 개념, 사건과 같이 유무형의 정보를 가지고 있는 독립적인 실체</u>를 말한다. 개체는 비슷한 속성을 가진 개체 타입을 구성하며, 개체 집합으로 묶인다.    
개체 타입 : **개체 집합**은 <u>공통된 속성을 가진 개체들의 모임</u>이며, **개체 타입**은 <u>개체 집합의 이러한 동일한 특징을 나타내는 용어</u>이다.

개체는 다음과 같은 특징을 가진다.

* 유일한 식별자에 의해 식별할 수 있다.
* 꾸준한 관리를 필요로 하는 정보이다.
* 두 개 이상 영송적으로 존재해야 한다.
* 업무 프로세스에 이용된다.
* 반드시 자신의 특징을 나타내는 속성을 포함한다.
* 다른 개체와 최소한 한 개 이상의 관계를 맺고 있다.

---

##### 개체 타입의 ER 다이어그램 표현

ER 다이어그램상에서 개체 타입은 직사각형으로 나타낸다. **강한 개체 타입**은 <u>직사각형</u>으로, **약한 개체 타입**은 <u>이중 직사각형</u>으로 나타낸다. 보통 개체 타입이라고 하면 강한 개체 타입을 말한다.

강한 개체 타입은 다른 개체의 도움 없이 독자적으로 존재 할 수 있다. 
반면 약한 개체 타입은 독자적으로 존재할 수 없고 반드시 상위 개체 타입을 가진다.
예를 들어 회사 데이터베이스에서 직원의 부양가족은 직원이 존재해야 존재할 수 있다. 따라서 직원은 강한 개체 타입이되고, 부양가족은 약한 개체 타입이 된다.

---

### 속성

속성은 개체가 가진 성질을 말한다.

---

##### 속성의 ER 다이어그램 표현

**속성**은 기본적으로 <u>타원</u>으로 표현하며 개체 타입을 나타내는 직사각형과 실선으로 연결된다. 속성이 개체를 <u>유일하게 식별할 수 있는 키일 경우 속성 이름에 밑줄을 긋는다.</u>
**약한 개체의 식별자**는 키를 갖지 못하고 대신 식별자를 가지며, 식별자 아래에 <u>점선을 긋는다.</u>

---

##### 속성의 유형

##### 단순 속성과 복합 속성

속성은 더 작은 단위로 분해할 수 있는지에 따라 단순 속성과 복합속성으로 구분할 수 있다. <u>단순속성은 더이상 분해가 불가능한 속성</u>이고, <u>복합속성은 독립적인 의미를 가진 속성으로 분해할 수 있는 속성</u>이다. **복합속성**은 <u>큰 타원 아래 작은 타원으로 연결</u>한다.

예를들어 주소의 경우 시, 동 단위로 분해할 수 있는 복합속성이다. 
분해된 시, 동의 경우 더 작게 분해할 수 없으므로 단순속성이다.

##### 단일값 속성과 다중값 속성

속성은 속성값의 개수에 따라 단일값 속성과 다중값 속성으로 구분할 수 있다. <u>단일값 속성은 하나의 값만을 가지는 속성</u>이고, <u>다중값 속성은 여러 개의 값을 가지는 속성</u>이다. **다중값 속성**은 <u>이중타원</u>으로 표현한다.

예를 들어 학생번호나 성명의 경우 한 사람이 하나의 값밖에 가지지 못하므로 단일값 속성이다. 
그러나 학위의 경우 한 사람이 학사를 취득한 후 석사를 취득하는 등 여러 개의 학위를 가질 수 있으므로 다중값 속성으로 볼 수 있다.

##### 저장 속성과 유도 속성

속성값이 다른 속성으로부터 유도될 수 있는 지에 따라 저장 속성과 유도 속성으로 구분할 수 있다. <u>저장속성은 다른 속성의 영향 없이 단독으로 저장되는 속성</u>이고, <u>유도 속성은 다른 저장 속성으로부터 유도된(계산된) 속성</u>이다. **유도속성**은 <u>점선타원</u>으로 표현한다.

예를들어 생년월일의 경우 학생 개개인이 가지고 있는 고유한 값으로 저장속성이며,
나이는 생년월일로부터 계산될 수 있는 값이므로 유도 속성이다.

---

### 관계와 관계 타입

ER 모델은 개체와 개체 사이의 관계를 표현한다. <u>관계는 개체 사이의 연관성을 나타내는 개념</u>이다. 예를 들어 '고객이 도서를 구입한다'라고 할 때 '고객' 개체타입과 '도서' 개체타입은 '구입한다'라는 개념으로 연결된다. 이러한 개체 간의 연관성을 관계라고 한다. **관계타입**은 <u>개체 타입과 개체 타입 간의 연결 가능한 관계를 정의(주문)</u>한 것이며, **관계 집합**은 <u>관계로 연결된 집합</u>을 의미한다.

---

##### 관계 타입의 ER 다이어그램 표현

**관계 타입**은 <u>마름모</u>로 표현한다.

---

##### 차수에 따른 관계 타입의 유형

관계 집합에 참여하는 개체 타입의 수를 관계 타입의 차수라고 한다.

* 1진 관계(순환적 관계)는 한 개의 개체가 자기 자신과 관계를 맺는다. 예를들어 학생 개체에서 학생들 간에 멘토링 관계를 맺으면 관계를 맺는 멘토와 멘티 모두 학생 개체가 된다.
* 2진 관계는 두 개의 개체가 관계를 맺는다. 예를 들어 학생 개체 타입과 학과 개체 타입은 '소속'이라는 관계를 맺고 있다.
* 3진 관계는 세 개의 개체가 관계를 맺는다. 예를 들어 자동차 회사 직원은 부품을 조립하여 하나의 자동차를 만드는 프로젝트를 '수행'하는 관계를 맺고 있다.

---

##### 관계 대응 수에 따른 관계 타입의 유형

두 개체 타입의 관계에 실제로 참여하는 개별 개체들의 수를 말한다.    
일대일 관계, 일대다 관계, 다대일 관계, 다대다 관계가 있다.

**일대일 관계(1:1)**
예를들어 회사에서 사원이 개인별로 한 대의 컴퓨터만 사용한다면 사우너과 컴퓨터는 일대일 관계이다.

**일대다(1:N), 다대일(N:1) 관계**
실제 일상생활에서 가장 많이 볼 수 있는 관계이다.
예를들어 학과와 학생의 소속 관계를 보면 하나의 학과에는 여러 명의 학생이 소속되어 있어 일대다 관계로 표현할 수 있다.

**다대다(N:M) 관계**
서로 복합 관계를 맺는다.
예를들어 학생과 강좌의 수강 관계를 보면, 한 학생은 여러 강좌를 수강할 수 있고, 한 강좌 역시 여러 학생들이 들을 수 있다.

---

##### 관계 대응 수의 최솟값과 최댓값

min은 관계에 참여하는 개체의 수가 적어도 min값이상이 되어야 한다는 뜻이며,
max는 관계에 참여하는 개체의 수가 max 값을 넘을 수 없다는 뜻이다.
예를들어 min값이 0일 경우 관계에 참여하는 개체의 수가 0 이상이므로 반드시 참여할 필요가 없다는 뜻이고, max 값이 10일 경우는 10개의 개체까지 참여할 수 있다는 뜻이다. max 값을 *로 표시하면 임의의 수만큼 참여할 수 있다는 뜻이다.

| 관계  |  (min1, max1) | (min2, max2)  |
|---|---|---|
| 1:1  | (0, 1)  | (0, 1)  |
| 1:N  | (0, *)  | (0, 1)  |
| N:M  | (0, *)  | (0, *)  |

---

##### is-a 관계

일부 개체 집합들이 맺고 있는 관계중에는 상하관계가 있다. <u>상위 개체 타입의 특성에 따라 하위 개체 타입이 결정되는 형태 is-a관계</u>라고 한다. 이때 상위 개체 타입을 슈퍼 클래스라고 하며, 하위 개체 타입을 서브 클래스라고 한다. **is-a** 관계는 <u>역삼각형</u>으로 표현하며, 역삼각형 위에는 슈퍼클래스 아래에는 서브 클래스를 관계실선으로 연결한다.

예를들어 상위 개체인 학생 개체 타입은 슈퍼클래스로, 학생이면 기본으로 가지는 공통 속성(학생번호 ,이름, 성별)을 가진다. 
학생을 휴학생(속성은 휴학일자, 사유), 재학생(등록학기, 지도교수), 졸업생(학위번호, 졸업일자)의 서브 클래스로 나누고 각 개체 타입에는 자신만이 가지고 있는 고유 속성을 부여한다.
재학생의 경우 슈퍼클래스의 속성인 (학생번호, 이름, 성별)을 상속받고, (등록학기, 지도교수) 속성을 포함하여 모두 다섯개의 속성을 가지게 된다.

---

##### 참여 제약조건

참여 제약조건은 개체 집합 내 모든 개체가 관계에 참여하는지에 따라 전체 참여와 부분 참여로 구분할 수 있다. **전체 참여**는 개체 타입과 관계를 <u>두 줄 실선</u>으로 표현하고, **부분 참여**는 일반적인 관계 표현과 같이 <u>단일 실선</u>으로 표현한다. 전체 참여를 (최솟값, 최댓값)으로 표현하면 최솟값이 1 이상으로 모두 참여한다는 뜻이고, 부분 참여는 최솟값이 0 이상이다.

예를들어 학생의 경우 교환학생이나 휴학 등의 이유로 수강을 하지 않는 학생도 있으므로 수강 관계와 부분 참여를 맺는다. 그러나 강좌의 경우 폐강되는 과목 없이 수강신청을 하는 학생이 반드시 있다고 가정하면 수강 관계와 전체 참여를 맺는다.

---

##### 역할

개체타입 간의 관계를 표현할 때 각 개체는 고유한 역할을 담당한다. 

예를들어 학생 개체 타입과 교수 개체 타입이 지도 관계를 맺을 때, 교수 개체 타입은 '지도한다', 학생 개체 타입은 '지도받는다'라는 역할을 한다. 일반적으로 역할은 관계만으로 알 수 있으면 생략한다.

---

##### 순환적 관계

<u>하나의 개체 타입이 동일한 개체 타입(자기자신)과 순환적으로 관계를 맺는 형태</u>를 말한다. 순환적 관계는 관계선을 개체 타입과 관계타입 양쪽에 두개를 그린다. 

예를들어 a는 학생들 간에 멘토링 관계를 맺어 맨토와 멘티 모두 학생 개체인 경우이며 b는 사원 개체는 자기보다 직위가 낮은 사원에게는 업무 지시를 내리고, 자기보다 직위가 높은 사원에게는 업무 지시를 받아 순환 관계를 맺는다.

---

##### 약한 개체 타입과 식별자

직원 개체 타입처럼 독립적을 식별할 수 있는 개체를 가지고 있는 개체 타입을 개체 혹은 강한 개체 타입이라고 한다. 이와 반대로 가족 개체 타입처럼 상위 개체 타입이 결정되지 않으면 개별 개체를 식별할 수 없는 종속된 개체 타입을 **약한 개체 타입**<u>(이중 직사각형으로 표현, 강한 개체 타입이 있어야 존재 가능)</u>이라고 한다.

강한 개체 타입은 직원 개체 타입의 '직원번호'와 같이 각 개체를 식별할 수 있는 기본키를 가진다. 약한 개체 타입은 자신의 기본키만으로 식별이 어려우므로 **강한 개체 타입의 기본키를 상속받아 사용**<u>(점선 밑줄로 표현)한다. 이를 식별자 혹은 부분키</u>라고 한다.

---

거의 총정리?

![](https://github.com/jm456789/jm456789.github.io/blob/main/_images/db_ex_1.jpg?raw=true)

위의 이미지를 보면 회사에서 직원 개체타입과 가족 개체 타입이 '부양'관계를 맺고 있다. 직원 개체 타입은 자기 자신만으로 존재 할 수 있고, 각각의 개체를 '직원번호'로 구분할 수 있다. 그러나 가족 개체 타입의 경우 직원번호 없이는 누구의 가족인지 알 수 없다. 또 '이름' 속성의 경우 직원 자녀 간에 같은 이름을 가진 사람이 있을 수 있으므로 직원번호와 함께 사용해야 한다.

<a href="https://github.com/jm456789/jm456789.github.io/blob/main/_images/db.pdf" target="_blank">pdf 보기</a>
